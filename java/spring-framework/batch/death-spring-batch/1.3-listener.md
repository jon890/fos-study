# Spring Batch Listener

- 리스너는 배치 처리의 주요 순간들을 관찰하고, 각 시점에 필요한 동작을 정의할 수 있는 도구
- 배치 처리 중 발생하는 특정 이벤트를 감지하고 원하는 로직을 실행 할 수 있게 해줌
- Job 시작 전후, Step 실행 전후는 물론, 청크 단위 또는 아이템 단위 처리 시점까지 모든 과정에 개입할 수 있음
- 이를 통해 로깅, 모니터링, 에러 처리등 우리가 원하는 로직을 자유롭게 추가 가능

## JobExecutionListener

- Job 실행의 시작과 종료 시점에 호출되는 리스너 인터페이스

```java
public interface JobExecutionListener {
    default void beforeJob(JobExecution jobExecution) { }
    default void afterJob(JobExecution jobExecution) { }
}
```

- beforeJob()
  - Job 실행 직전 호출
  - 필요한 리소스 준비등의 초기화 작업을 수행할 수 있음
- afterJob()
  - Job 실행 후에 호출
  - Job 실행 결과를 이메일로 전송, 리소스를 정리하는 등의 후처리 작업을 수행할 수 있음
  - Job의 성공/실패 여부와 관계없이 무조건 호출

## StepExecutionListener

- Step의 실행 시작과 종료 시점에 호출되는 리스너 인터페이스
- Step의 시작 시간, 종료 시간, 처리된 데이터 수를 로그로 기록하는 등의 사용자 정의 작업 추가 가능

```java
public interface StepExecutionListener extends StepListener {
    default void beforeStep(StepExecution stepExecution) {}

    @Nullable
    default ExitStatus afterStep(StepExecution stepExecution) {
        return null;
    }
}
```

- beforeStep()
  - Step의 시작 시점, 정확히는 StepScope가 활성화된 직후에 호출
- afterStep()
  – Step의 종료 시점에 호출
  - JobExecutionListener의 afterJob()과 마찬가지로 Step의 성공/실패 여부와 관계없이 무조건 호출

## ChunkListener

- 청크 단위 처리가 시작되기 전, 완료된 후, 실행 도중 에러가 발생했을 때 호출되는 리스너 인터페이스

```java
public interface ChunkListener extends StepListener {
    default void beforeChunk(ChunkContext context) { }
    default void afterChunk(ChunkContext context) { }
    default void afterChunkError(ChunkContext context) { }
}
```

- afterChunk()
  - 트랜잭션이 커밋된 후에 호출
- afterChunkError()
  - 청크 트랜잭션이 롤백된 이후에 호출

### Tasklet 지향 Step에서도 동작한다.

- 이름과 달리 ChunkListener는 청크 지향 Step뿐만 아니라 Tasklet 지향 Step에서도 동작
- Tasklet의 execute() 호출 전후, 그리고 execute() 실행 중 오류 발생 시에도 실행 됨
- Tasklet 지향 Step에서도 ChunkListener를 활용한 모니터링이 가능
- execute()에서 `RepeatStatus.CONTINUABLE`을 반환하면 execute() 실행이 반복되므로, 해당 범위로 동작

## Item[Read|Process|Write]Listener

- 아이템 읽기, 처리, 쓰기 작업이 수행되는 시점에 호출되는 리스너 인터페이스

```java
public interface ItemReadListener<T> extends StepListener {
    default void beforeRead() { }
    default void afterRead() { }
    default void onReadError(Exception ex) { }
}

public interface ItemProcessListener<T, S> extends StepListener {
    default void beforeProcess(T item) { }
    default void afterProcess(T item, @Nullable S result) { }
    default void onProcessError(T item, Exception e) { }
}

public interface ItemWriteListener<S> extends StepListener {
    default void beforeWrite(Chunk<? extends S> items) { }
    default void afterWrite(Chunk<? extends S> items) { }
    default void onWriteError(Exception exception, Chunk<? extends S> items) { }
}
```

- 눈여겨봐야 할 포인트
  - `ItemReadListener.afterRead()`는 ItemReader.read() 호출 후에 호출되지만, ItemReader.read() 메서드가 더 이상 읽을 데이터가 없어 `null`을 반환할 떄는 호출되지 않음
  - `ItemProcessListener.afterProcess`는 ItemProcessor.process() 메서드가 `null`을 반환하더라도 호출된다.
    - 참고로 ItemProcessor에서 `null`을 반환하는 것은 해당 데이터를 필터링하겠다는 의미
  - `ItemWriteListener.afterWrite()`는 트랜잭션이 커밋되기 전, 그리고 ChunkListener.afterChunk()가 호출되기 전에 호출된다

## 여기까지의 흐름도

### 전체 Job / Step 실행 흐름

```text
            +----------------+
            |  JobLauncher   |
            +----------------+
                    |
                    | beforeJob()
                    v
              +-------------+
              |     Job     |
              +-------------+
                    |
                    | beforeStep()
                    v
              +-------------+
              |    Step     |
              +-------------+
                    |
                    | beforeChunk()
                    v
        ==================================
        ||        Chunk #N              ||
        ==================================
                    |
                    v
              [ Item Processing ]
                    |
                    ^
                    | afterChunk()
              +-------------+
              |    Step     |
              +-------------+
                    |
                    | afterStep()
                    v
              +-------------+
              |     Job     |
              +-------------+
```

### Chunk 내부 상세 흐름 (Reader -> Processor -> Writer)

```text
+--------------------------------------------------+
|                    Chunk #N                      |
|                                                  |
|   beforeRead()                                   |
|        |                                         |
|        v                                         |
|      read()      --- 반복 ---                    |
|        |                                         |
|   afterRead()                                    |
|                                                  |
|   beforeProcess()                                |
|        |                                         |
|        v                                         |
|     process()   --- 반복 ---                     |
|        |                                         |
|   afterProcess()                                 |
|                                                  |
|   beforeWrite()                                  |
|        |                                         |
|        v                                         |
|      write()    (List 단위)                      |
|        |                                         |
|   afterWrite()                                   |
|                                                  |
+--------------------------------------------------+
```

## 리스너 활용

- 단계별 모니터링과 추적
  - Job과 Step 실행 전후에 로그를 남길 수 있음
  - Step이 언제 시작하고, 언제 끝났는지, 몇 개의 데이터를 처리했는지를 기록하고 추적 가능
- 실행 결과에 따른 후속 처리
  - 예를 들어, Job의 종료 상태를 확인하고 종료 상태에 따른 후속 조치를 취할 수 있음
- 데이터 가공과 전달
  - 예를 들어, Step 간에 데이터를 전달하거나, 다음 처리에 필요한 정보를 미리 준비할 수 있음
- 부가 기능 분리
  - 예를 들어, 오류가 발생한 경우 메서드에서 관리자에게 알림 메일 보내는 등의 부가적인 일을 분리할 수 있음
