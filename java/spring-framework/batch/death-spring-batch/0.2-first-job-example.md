## Spring Boot를 활용하여 프로젝트를 구성해보자.

Spring Initializer를 사용해 프로젝트를 생성해보자.

Spring Initializer는 Spring Boot 프로젝트를 빠르게 생성할 수 있는 공식 도구다.

> [https://start.spring.io](https://start.spring.io) 웹사이트나 IntelliJ IDEA의 내장 Spring Initializer 기능으로도 생성할 수 있다.
>
> 하지만 CLI 방식이 가장 빠르고 반복 가능한 방법이다.

<br>

```sh
mkdir first-batch
cd first-batch

curl 'https://start.spring.io/starter.tgz' \
    -d type=gradle-project-kotlin \
    -d language=java \
    -d bootVersion=3.5.9 \
    -d groupId=com.batch \
    -d artifactId=first-batch \
    -d name=first-batch \
    -d packageName=com.batch \
    -d packaging=jar \
    -d javaVersion=21 \
    -d dependencies=batch,h2 \
    | tar -xzvf -
```

<br>

위 명령어를 수행해, 샘플 프로젝트를 만들어보자.

생성된 `build.gradle.kts` 파일을 보면 `spring-boot-starter-batch`라는 의존성이 추가된 것을 알 수 있다.

<br>

`spring-boot-starter-batch`는 Spring Batch 개발에 필요한 모든 의존성을 포함하고 있는 스타터 패키지다.

`spring-batch-core`는 물론, Spring Boot의 자동 설정(Auto Configuration) 기능까지 함께 제공한다.

이를 통해 Spring Batch 실행에 필요한 핵심 Bean들이 자동으로 구성되어, 개발자는 복잡한 설정 작업 없이 바로 비즈니스 로직에 집중할 수 있다.

<br>

또한 메인 애플리케이션 클래스도 자동으로 생성된다 `FirstBatchApplication`

이 메인 클래스가 진입점이 되고, Spring Boot 환경에서는 `JobLauncherApplicationRunner`라는 별도의 컴포넌트가 자동으로 배치 Job 실행을 담당한다.

> JobLauncherApplicationRunner가 어떻게 동작하는지에 대한 설명은 뒤에서 만나게 될 것이다.
>
> 지금은 Spring Boot가 배치 실행을 자동화해준다는 점만 기억하자.

<br>

### 작은 팁

<br>

자동 생성된 FirstBatchApplication의 코드를 다음과 같이 수정하자.

```java
@SpringBootApplication
public class FirstBatchApplication {
  public static void main(String[] args) {
    System.exit(SpringApplication.exit(SpringApplication.run(FirstBatchApplication.class, args)));
  }
}
```

<br>

배치 애플리케이션에서는 이와 같이 `SpringApplication.run()`의 결과를 `System.exit()`로 처리하는 것이 권장된다.

배치 작업의 성공/실패 상태를 exit code로 외부 시스템에 전달할 수 있어 실무에서 배치 모니터링과 제어에 필수적이기 때문이다.

배치 작업의 exit code를 다루는 방법은 뒤에서 더 살펴볼 것이다.

<br>

<br>

## 2단계 : 첫 번째 배치 잡

<br>

첫 번째 배치를 시뮬레이션해보자.

우리는 'System Termination'이라는 가상의 세계에 입장할 것이다.

이곳에서 프로세스들을 처형하는 배치잡을 실행하게 될 것이다.

<br>

시나리오는 다음과 같다

- 세계에 입장 (enterWorldStep)
- 시스템 관리자 NPC 만남 (meetNPCStep)
- 프로세스 처형 미션 수행 (defeatProcessStep)
- 미션 완료 보고 (completeQuestStep)

<br>

### 시스템 뼈대 구축 및 비즈니스 로직 설정

> 다음의 코드를 살펴보자. 어딘가 익숙하지 않은가?
>
> 그렇다. Job과 Step의 구성이 일반적인 Spring 설정과 동일하다.
>
> 이처럼 Spring Batch를 사용하면 우리가 알던 방식 그대로 배치 시스템을 설계할 수 있다.

**FirstJobConfig.java**

```java
@Configuration
@RequiredArgsConstructor
public class FirstJobConfig {

    private final JobRepository jobRepository;
    private final PlatformTransactionManager transactionManager;

    private final int TERMINATION_TARGET = 5;
    private final AtomicInteger processesKilled = new AtomicInteger(0);


    @Bean
    public Job firstJob() {
        return new JobBuilder("firstJob", jobRepository)
            .start(enterWorldStep())
            .next(meetNPCStep())
            .next(defeatProcessStep())
            .next(completeQuestStep())
            .build();
    }


    @Bean
    public Step enterWorldStep() {
        return new StepBuilder("enterWorldStep", jobRepository)
            .tasklet((contribution, chunkContext) -> {
                System.out.println("System Termination 시뮬레이션 세계에 접속했습니다!");
                return RepeatStatus.FINISHED;
            }, transactionManager)
            .build();
    }


    @Bean
    public Step meetNPCStep() {
        return new StepBuilder("meetNPCStep", jobRepository)
            .tasklet((contribution, chunkContext) -> {
                System.out.println("시스템 관리자 NPC를 만났습니다.");
                System.out.println("첫 번째 미션: 좀비 프로세스 " + TERMINATION_TARGET + "개 처형하기");
                return RepeatStatus.FINISHED;
            }, transactionManager)
            .build();
    }


    @Bean
    public Step defeatProcessStep() {
        return new StepBuilder("defeatProcessStep", jobRepository)
            .tasklet((contribution, chunkContext) -> {
                int terminated = processesKilled.incrementAndGet();
                System.out.println("좀비 프로세스 처형 완료! (현재 " + terminated + "/" + TERMINATION_TARGET + ")");
                if (terminated < TERMINATION_TARGET) {
                    return RepeatStatus.CONTINUABLE;
                } else {
                    return RepeatStatus.FINISHED;
                }
            }, transactionManager)
            .build();
    }


    @Bean
    public Step completeQuestStep() {
        return new StepBuilder("completeQuestStep", jobRepository)
            .tasklet((contribution, chunkContext) -> {
                System.out.println("미션 완료! 좀비 프로세스 " + TERMINATION_TARGET + "개 처형 성공!");
                System.out.println("보상: kill -9 권한 획득, 시스템 제어 레벨 1 달성");
                return RepeatStatus.FINISHED;
            }, transactionManager)
            .build();
    }
}
```

<br>

- 첫 번째 배치 실행을 위한 설정 클래스를 만들어보자.
- 복잡한 인프라 설정은 Spring Boot가 알아서 처리해주므로, 우리는 핵심 비즈니스 로직에만 집중하면 된다.
  - Spring Boot가 배치 코어 컴포넌트와 관련된 핵심 인프라 Bean들을 자동으로 구성해주기 때문이다.

<br>

### 주입받는 Bean들에 대해 간략하게 알아보자

- JobRepository
  - Spring Batch는 Job과 Step의 실행 정보(메타데이터)를 데이터베이스에 저장한다.
  - Job의 실행 정보를 관리하는 핵심 인터페이스.
  - Job의 실행 이력, 상태 결과 등 모든 메타데이터가 관리됨
- PlatformTransactionManager
  - 메타데이터 저장과 배치 작업 실행 등 Spring Batch의 모든 작업은 트랜잭션 내에서 처리된다.
  - 이를 위해 배치 코어 컴포넌트와 우리 Job에서 공통으로 사용할 `PlatformTransactionManager`를 주입받는다.

<br>

### Job 구성

코드를 보면 Job 구성 메서드에 @Bean 어노테이션이 붙어있는 것을 알 수 있다.

이는 이 Job이 Spring 빈으로 등록되어 Spring 컨테이너에 의해 관리된다는 것을 의미한다.

Spring Batch는 Job을 실행할 때 Spring 컨테이너에서 Job 빈을 찾아 실행하기 때문에, Job은 반드시 Bean으로 등록해주도록 한다.

<br>

```java
@Bean
public Job firstJob() {
    return new JobBuilder("firstJob", jobRepository)
            .start(enterWorldStep())
            .next(meetNPCStep())
            .next(defeatProcessStep())
            .next(completeQuestStep())
            .build();
}
```

<br>

다음으로 Job이 어떻게 만들어지는지 살펴보자.

<br>

코드를 보면 JobBuilder를 사용해 Job을 생성하고있다.

JobBuilder의 첫 번째 파라미터로는 Job의 이름을 지정하는데, 이 이름은 나중에 해당 Job의 상태를 추적하거나 제어할 떄 사용된다.

두 번째 파라미터로는 JobRepository를 전달하는데, 위에서 설명한대로 Job의 실행정보를 관리한다.

<br>

Job의 구성을 보면, `start()` 메서드로 처음 실행할 Step을 지정하고, `next()`메서드를 통해 순차적으로 실행될 다음 Step들을 정읳나다.

이렇게 정의된 Step들은 이전 Step이 성공적으로 완료된 후에만 실행된다.

<br>

다음으로 각 Step의 구현을 살펴보자.

<br>

### Step 구성

<br>

```java
@Bean
public Step enterWorldStep() {
    return new StepBuilder("enterWorldStep", jobRepository)
            .tasklet((contribution, chunkContext) -> {
                System.out.println("System Termination 시뮬레이션 세계에 접속했습니다!");
                return RepeatStatus.FINISHED;
            }, transactionManager)
            .build();
}
```

<br>

첫 번쨰 Step의 코드를 살펴보자.

<br>

StepBuilder를 통해 Step을 생성하는 것을 볼 수 있다.

StepBuilder의 첫 번째 파라미터로는 Step의 식별자를 지정하는데, 이는 후에 잡과 스텝의 상태를 추적하고 제어할 떄 사용된다.

또한 JobBuilder와 마찬가지로 StepBuilder에도 JobRepository를 전달하여 Step의 실행 정보가 관리될 수 있도록 한다.

<br>

Step의 실제 동작은 tasklet() 메서드를 통해 정의된다.

예제에서는 System.out.println()을 통해 시뮬레이션 시작을 알리는 간단한 로직을 구현했다.

주입받은`PlatformTransactionManager`가 이 지점에서 사용되고 있는데, tasklet() 메서드와 `PlatformTransactionManager`의 관계는 차근차근 알게 될 것이다.

<br>

> 배치는 데이터를 읽고, 처리하고, 쓰는 게 일반적인 패턴이라며?
>
> 그런데 우리 예제의 Job 구성 코드에 어디에도 데이터 처리를 담당하는 ItemReader, ItemWriter 등의 컴포넌트가 보이지 않는다
>
> **걱정 마라**
>
> <br>
>
> 앞서 말했듯 Spring Batch는 단순한 데이터 이동만을 위한 도구가 아니다.
>
> **파일 복사, 디렉토리 정리, 알림 발송** 같은 작업도 배치에서 처리한다.

<br>

## 3단계: Batch 실행

<br>

Spring Boot 환경이므로 `bootRun` task를 통해 배치 Job을 실행해보자.

```bash
./gradlew bootRun --args='--spring.batch.job.name=firstJob'
```

<br>

명령어를 보면 `--spring.batch.job.name` 프로퍼티에 실행할 Job의 이름을 지정하는 것을 알 수 있다.

앞서 잠깐 언급했듯이, `JobLauncherApplicationRunner`가 `spring.batch.job.name` 프로퍼티에 지정된 Job을 찾아 실행해준다.

<br>

```text
System Termination 시뮬레이션 세계에 접속했습니다!
2025-12-29T19:28:10.774+09:00  INFO 40395 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [enterWorldStep] executed in 64ms
2025-12-29T19:28:10.774+09:00  INFO 40395 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [meetNPCStep]
시스템 관리자 NPC를 만났습니다.
첫 번째 미션: 좀비 프로세스 5개 처형하기
2025-12-29T19:28:10.774+09:00  INFO 40395 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [meetNPCStep] executed in
2025-12-29T19:28:10.774+09:00  INFO 40395 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [defeatProcessStep]
좀비 프로세스 처형 완료! (현재 1/5)
좀비 프로세스 처형 완료! (현재 2/5)
좀비 프로세스 처형 완료! (현재 3/5)
좀비 프로세스 처형 완료! (현재 4/5)
좀비 프로세스 처형 완료! (현재 5/5)
2025-12-29T19:28:10.775+09:00  INFO 40395 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [defeatProcessStep] executed in
2025-12-29T19:28:10.775+09:00  INFO 40395 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [completeQuestStep]
미션 완료! 좀비 프로세스 5개 처형 성공!
보상: kill -9 권한 획득, 시스템 제어 레벨 1 달성
2025-12-29T19:28:10.775+09:00  INFO 40395 --- [           main] o.s.batch.core.step.AbstractStep         : Step: [completeQuestStep] executed in
2025-12-29T19:28:10.776+09:00  INFO 40395 --- [           main] o.s.b.c.l.s.TaskExecutorJobLauncher      : Job: [SimpleJob: [name=firstJob]] completed with the following parameters: [{}] and the following status: [COMPLETED] in 66ms
```
