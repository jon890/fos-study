# FaultTolerant (작성 중..)

배치 작업에서 실패는 피할 수 없는 현실이다. 파일에 일부 잘못된 데이터가 저장되었을 수도 있고, 데이터베이스와의 토잇ㄴ이 일시적으로 실패할 수도이 있다. 그렇다고 해서 배치 작업이 중단되어도 괜찮을까?

## Spring Batch의 잔인한 기본 오류 처리

**스텝 실행 중 단 하나의 예외라도 발생하면?**

ItemReader에서 읽는 중이든, ItemProcessor에서 처리 중이든, ItemWriter에서 쓰는 중이든 Spring Batch는 즉시 모든 실행을 중단하고 배치 잡 전체를 실패로 처리한다.

하지만 생각해보자.

- 1,000만 개의 데이터를 처리하다 단 한 건의 오류로 작업을 실패시켜야 한다면?
- 일시적인 네트워크 오류나 잘못된 형식의 데이터 하나 때문에 전체 배치를 다시 실행해야 한다면?

적절한 예외 처리 방법으로 재시도 가능한 예외는 재시도하고, 무시해도 되는 예외는 무시할 수 있어야 한다. <br>
그러나 이게 구조적으로 쉽지만은 않다. 우리가 지금까지 살펴본 *청크 지향 처리*의 구조를 생각해보자.

### 청크 지향 처리의 구조적 한계

개발자는 ItemReader, ItemProcessor, ItemWriter 구현체를 스텝에 구성만할 뿐, 실제 실행은 Spring Batch의 Step이 담당한다. 즉, 아이템 처리 중 예외가 발생해도 우리가 직접 개입할 기회가 없다.

다행이 이런 구조적 한계를 보완하기 위해 Spring Batch는 **내결함성(FaultTolerance)기능**을 제공한다. <br>
이를 활용하면 간단한 구성만으로도 **재시도(Retry)**와 **건너뛰기(Skip)**로 청크 지향 처리에서 발생할 수 있는 다양한 예외 상황을 다룰 수 있다.

예를 들어,

- 일시적 네트워크 오류로 인한 데이터베이스 쓰기 실패는 재시도로 해결할 수 있고,
- 잘못된 형식의 데이터를 읽어 예외가 발생한 경우에는 건너뛰기로 깔끔하게 무시해버릴 수 있다.

> 참고 : 태스크릿 지향 처리는 내결함성(FaultTolerance)를 지원하지 않는다. <br>
> 우리가 작성한 코드 내에서 `try-catch`를 사용해 발생 가능한 예외를 원하는 대로 처리할 수 있기 때문이다.

Spring Batch의 **내결함성(FaultTolerance)기능**은 크게 두 가지 무기를 제공한다. <br>
**재시도**와 **건너뛰기**이다. <br>
먼저 재시도부터 살펴보자.

## 재시도(Retry)

말 그대로 실패한 작업을 다시 시도하는 것이다. <br>
예를 들어 쓰기 중 데이터베이스 커넥션이 순간적으로 끊기거나 ItemProcessor의 외부 API 호출에서 일시적으로 타임아웃이 발생했을 떄, 잠시 후 다시 시도하면 정상적으로 처리될 가능성이 높다. <br>
이런 일시적인 오류 상황에서 재시도는 매우 효과적인 해결책이 된다.

### 내결함성 기능의 핵심 무기 - RetryTemplate

내결함성 기능을 활성화하면 스텝은 RetryTemplate이라는 무기를 장착하게 된다. <br>
**RetryTemplate**은 Spring Retry 프로젝트의 핵심 컴포넌트로, **작업이 실패하면 정해진 정책에 따라 다시 시도**하는 컴포넌트다.

RetryTemplate의 메커니즘을 들여다보자. 다음 다이어 그램은 **RetryTemplate.execute()** 메서드가 내부적으로 어떻게 동작하는지를 단순화해서 보여준다.

```text
RetryTemplate.execute()
        |
        v
    canRetry()?   <-- RetryPolicy 판단
       / \
      /   \
   YES     NO
    |       |
    v       v
retryCallback()   recoveryCallback()
 (재시도 수행)     (복구 로직 수행)
```

- **재시도 가능 여부 판단 - canRetry()**
  - 먼저 **canRetry()**를 통해 재시도 가능 여부를 판단한다.
  - 이 메서드는 사전에 정해진 재시도 정책(RetryPolicy)을 기반으로 <b>"이 작업을 다시 시도해도 되는가?"</b>를 결정한다.
- **핵심 로직 실행 - retryCallback**
  - 재시도가 가능하다고 판단되면 **retryCallback**을 호출한다.
  - 여기에는 우리가 실행하고자하는 핵심 비즈니스 로직이 담겨있다.
  - 중요한 점은 이 콜백이 재시도만을 위한 것이 아니라는 점이다.
  - 내결함성 기능이 활성화되면 최초 실행부터 재시도까지 모든 시도가 이 **retryCallback**을 통해 수행된다.
  - 즉, 정상적인 첫 실행도, 실패 후 재시도도 모두 RetryTemplate의 관할 하에 있다는 뜻이다.
- **최후의 수단 - recoveryCallback**
  - 만약 <b>canRetry()</b>가 "더 이상 재시도는 불가능하다"고 판단하면 어떻게 될까?
  - 이 떄 호출되는 것이 바로 **recoveryCallback**이다.
  - 최후의 수단으로, 기본적으로는 발생한 예외를 그대로 전파하거나 대체 로직을 수행한다.

<br>

이 메커니즘이 Spring Batch Step에 장착되면 어떤 일이 벌어질까?

```text
                         Rollback
                           ↺
                        +-------+
                        | Step  |
                        +-------+
                           ^
                           |  예외 발생 / 전파
                           |
        실패없이 청크처리 재개   |  input chunk
                           |
                           v
        +----------------------------------------------------+
        |                  RetryTemplate                     |
        |                                                    |
        |                 +-------------+                    |
        |                 |  canRetry?  |                    |
        |                 +-------------+                    |
        |                       |                            |
        |                 +-----+-----+                      |
        |                 |           |                      |
        |               YES           NO                     |
        |                 |           |                      |
        |                 v           v                      |
        |        +----------------+  +--------------------+  |
        |        | retryCallback  |  | recoveryCallback   |  |
        |        +----------------+  +--------------------+  |
        |                 |                                  |
        |                 v                                  |
        |     +-------------------------------------------+  |
        |     | ItemProcessor.process()                   |  |
        |     | ItemWriter.write()                        |  |
        |     +-------------------------------------------+  |
        +----------------------------------------------------+
                          |
                          v
                 step 실패 (별도 구성 없을 경우)

```

- 내결함성 모드가 활성화되면, ItemProcessor와 ItemWriter 호출 로직이 RetryTemplate의 **retryCallback**안으로 패키징된다.
- 이 말인 즉, ItemProcessor와 ItemWriter 호출의 재시도뿐만 아니라 최초 실행 또한 이 RetryTemplate을 통해 수행된다는 뜻이다.

그렇다면 **canRetry()** 메서드에서는 재시도 가능 여부를 어떻게 판단할까?

### 재시도의 심판관 - RetryPolicy

바로 **RetryPolicy**라는 재시도 정책을 사용해 재시도 가능 여부를 결정한다. <br>
별도 설정이 없을 경우 Spring Batch는 **SimpleRetryPolicy**라는 재시도 정책을 사용한다.

SimpleRetryPolicy는 다음의 두 조건을 바탕으로 재시도 가능 여부를 결정한다.

- **발생한 예외가 사전에 지정된 예외 유형에 해당하는가**
- **현재 재시도 횟수가 최대 허용 횟수를 초과하지 않았는가**

### ItemReader? 재시도는 없다

ItemReader는 재시도 기능의 보호 대상이 아니다. 다시 말해, ItemReader에서 발생한 예외는 재시도되지 않는다. <br>
그 이유는 Spring Batch가 mutable한 데이터소스로부터 데이터를 읽는 상황까지 고려했기 때문이다.

> **Mutable한 데이터 소스란?** <br>
> 읽으연 데이터가 사라지는 데이터 소스를 의미한다. 대표적으로 <b>메시지 큐(RabbitMQ, SQS 등)</b>를 예로 들 수 있다. <br>
> 이러한 상황에서는 재시도가 불가능하다.

> 아이러니하게도, 대부분의 데이터소스(파일, DB, Kafka)는 immutable 하다. 즉, 원본이 그대로 보존되며 재시도 가능한 구조를 가지고 있다. <br>
> Spring Batch에서도 v6 부터는 ItemReader에서도 재시도가 가능해질 예정이다.

### 내결함성 최적화 - Input Chunk 재활용

앞선 다이어그램을 다시 살펴보자. Step에서 RetryTemplate으로 향하는 화살표를 보면, 롤백 후 청크 처리를 재개한 Step이 RetryTemplate에 input chunk를 전달하고 있는 것이 보인다.

여기서 반드시 알아야 할 ItemReader의 중요한 설계 원칙이 있다. <br>
ItemReader의 기본 규약은 **forward only** 방식이다. **즉 데이터를 단방향으로만 순차적으로 읽어나가는 것이 기본 원칙이다.** <br>
따라서 과거로 되돌아가 아이템을 다시 읽는 것은 ItemReader의 기본 설계 원칙에 위배된다.

_그렇다면 어떻게 매번 재시도 마다 input chunk를 전달할 수 있을까?_

답은 내결함성 기능의 청크 버퍼링에 있다. <br>
Spring Batch는 내결함성 기능이 활성화된 경우 ItemReader가 읽어들인 input Chunk를 별도로 저장해둔다.

자, 지금까지 RetryTemplate이 Spring Batch Step과 어떻게 결합되는지 이해했다. <br>
이제 실제로 우리 스텝에 이 강력한 재시도 기능을 장착하는 방법을 알아보자.

## 예제 1 - 재시도 설정

```java
@Bean
public Step terminationRetryStep() {
  return new StepBuilder("terminationRetryStep", jobRepository)
            .<Scream, Scream>chunk(3, transactionManager)
            .reader(terminationRetryReader())
            .processor(terminationRetryProcessor())
            .writer(terminationRetryWriter())
            .faultTolerant() // 내결함성 기능 ON
            .retry(TerminationFailedException.class)
}
```
