# 배치의 생사를 쥐다 : JobParameters

- 배치의 운명을 결정짓는 통제 변수
  - 특정 날짜, 파일 경로, 쿼리 조건...

## JobParameters란 무엇인가?

**JobParameters**는 배치 작업에 전달되는 입력 값, 이 값 은 배치가 어떤 조건에서, 어떤 데이터를 다룰지 결정하는 데 핵심적인 역할을 한다.

배치 잡을 동적이고 유연하게 만들어 주는 도구.

그런데 여기서 의문이 들 수 있다.

"그냥 -D 옵션으로 프로퍼티 전달하면 되는 거 아닌가?"

그럴 듯하게 들리지만, JobParameters와 프로퍼티는 완전히 다른 목적을 가진다.
JobParameters는 단순한 값 전달을 넘어서, 배치의 실행과 제어를 관리하는 핵심 메커니즘

## 프로퍼티와 JobParameters의 결정적 차이

- **1. 입력값 동적 변경**
  - 프로퍼티는 앱 시작 시 한 번 주입되는 정적인 값
  - 별도의 부가적인 처리 없이 실행 중인 앱에 동적으로 값을 변경할 수는 없다.
- **2. 메타데이터**
  - Spring Batch는 JobParameters의 모든 값을 메타데이터 저장소에 기록하며, 이를 통해 다음과 같은 기능을 제공한다.
  - Job 인스턴스 식별 및 재시작 처리
  - Job 실행 이력 추적

## JobParameters 전달하기

- 실제 운영 환경에서는 커맨드 라인을 통해 파라미터를 전달하는 방식이 핵심이다.
- 왜일까? 대부분의 스케줄러와 자동화 도구들이 커맨드라인 실행을 기본으로 지원하기 때문이다.

- **1. 커맨드라인에서 잡 파라미터 전달하기**
  ```sh
  ./gradlew bootRun --args='--spring.batch.job.name=dataProcessingJob inputFilePath=/data/input/users.csv,java.lang.String'
  ```
  - 대충 보아하니, 이름, 값, 파라미터 타입으로 구성된 것 같다
  - 주의사항
    - `--`로 시작하는 Spring Boot의 파라미터와 그 뒤에 따라오는 Spring Batch의 잡 파라미터를 구분하라.
    - `--spring.batch.job.name`은 실행할 Job의 이름을 지정하는 Spring Boot 애플리케이션의 아규먼트이다.
    - 그 뒤의 `key=value,type`들이 실제 Job에 주입되는 Spring Batch JobParameters이다.
  - JobParameters의 기본 표기법
    ```sh
    parameterName=parameterValue,parameterType,identificationFlag
    ```
    - parameterName : 배치 Job에서 파라미터를 찾을 때 사용할 key 값, 이 이름으로 Job 내에서 파라미터에 접근할 수 있다.
    - parameterValue : 파라미터의 실제 값
    - parameterType : 파라미터의 타입 (java.lang.String, java.lang.Integer와 같은 fully qualified name 사용)
      - 이 타입을 명시하지 않을 경우 해당 파라미터를 `String` 타입으로 가정한다.
    - identificationFlag : JobInstance 식별에 사용될 파라미터인지 여부를 전달하는 값으로 `true`이면 식별에 사용된다는 의미
      - 생략할 경우 `true`로 설정된다.
  - parameterType에는 어떤 값이 올 수 있을까?
    - `Integer`, `Boolean`과 같은 기본 타입은 물론 그 외 DefaultConversionService가 제공하는 다양한 타입으로의 변환을 지원한다.

## 실제로 코딩해보기

- src/config/SystemTerminatorConfig.java 참고
- 주의사항
  - `@Value`를 사용해 잡 파라미터를 전달받으려면, `@StepScope`와 같은 특별한 애노테이션을 선언해야 한다
  - 자세한 내용은 뒤에 다룰 예정

## Job과 Step의 Scope 이해하기

- 일반적인 Spring 애플리케이션의 기본 스코프인 싱글톤과는 다른 특별한 스코프를 제공
- JobScope와 StepScope가 선언된 빈은 애플리케이션 구동 시점에는 우선 프록시 객체로만 존재
- 그 후 Job이나 Step이 실행된 후에 프록시 객체에 접근을 시도하면 그 떄 실제 빈이 생성 됨
- 각각 스코프 빈은 Job과 Step의 실행(Execution) 시점에 생성되어 종료할 때 함께 소멸된다

### @JobScope

- Job이 실행될 때 실제 빈이 생성되고, Job이 종료될 때 함께 제거되는 스코프다.
- 즉, JobExecution과 생명주기를 같이 한다.

- Step에 `@JobScope`를 사용하면 어떻게 영향을 미치는지 파악해보자
  - 지연된 빈 생성
  - Job 파라미터와의 연동
  - 병렬 처리 지원

### @StepScope

- `@JobScope`와의 차이는 `@StepScope`는 Step의 실행 범위에서 빈을 관리
- 예를 들어, Taaklet 빈에 `@StepScope`를 붙이면, 이 Tasklet 빈이 Step의 생명주기와 함께한다는 것을 의미
- 즉, 각각의 Step 실행마다 새로운 tasklet이 생성되고, Step이 종료될 떄 함께 제거

### JobScope와 StepScope 사용 시 주의사항

- **1. 프록시 대상의 타입이 클래스인 경우 반드시 상속 가능한 클래스여야 한다**
  - 이 스코프들은 CGLIB를 사용해 클래스 기반의 프록시를 생성한다.
  - 당연히 프록시를 생성하려면 대상 클래스가 상속 가능해야 한다.
- **2. Step 빈에는 `@StepScope`와 `@JobScope`를 사용하지 말라**
  - Spring Batch는 Step 실행 전 메타데이터 관리를 위해 Step 빈에 접근해야 한다
  - 문제는 이 시점에 아직 Step이 실행되지 않아, `@StepScope`가 활성화되지 않았다는 것이다.
  - 결국 스코프가 활성화되지 않은 상태에서 프록시에 접근하려니 **시스템이 폭발**하는 것이다.

## ExecutionContext

- Spring Batch는 JobExecution과 StepExecution을 사용해 시작 시간, 종료 시간, 실행 상태 같은 메타데이터를 관리
- 하지만 이런 실행 정보만으로는 시스템을 완벽하게 제어하기 부족할 떄가 있음
- 커스텀 데이터를 관리할 때 사용하는 것이 바로 ExecutionContext라는 데이터 컨테이너
- ExecutionContext 데이터 역시 JobParameters와 마찬가지로 `@Value`를 통해 주입받을 수 있다.

<br />

- Step의 ExecutionContext에 저장된 데이터는, `@Value("#{jobExecutionContext['key']}")`로 접근할 수 없다.
  - 즉, Step 수준의 데이터를 Job 수준에서 가져올 수 없다
- 한 Step의 ExecutionContext는 다른 Step에서 접근할 수 없다.
  - 예를 들어, StepA의 ExecutionContext에 저장된 데이터를 StepB에서 가져올 수 없다.
- 위와 같이 구성되어, **Step 간의 데이터 독립성을 완벽하게 보장**
