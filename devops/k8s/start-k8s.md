# Kubernetes 공부 시작

## 컨테이너 개념부터 다시 정리

컨테이너 : **어떤 애플리케이션을 어디서 돌리든 동일하게 돌도록 만드는 격리된 실행 환경**

- **1. 컨테이너의 핵심 특징**

  - 이미지(Image): 실행 환경 + 코드 + 라이브러리가 통째로 들어있는 스냅샷
    - (예) `openjdk:17-alpine + jar파일`
  - 컨테이너 : 이미지를 실행한 상태 (프로세스)
  - 불변성 : 한 번 빌드한 이미지는 어떤 서버에서 실행하든 환경 차이가 없어야 한다
  - 격리 : OS 전체를 가상화하지 않고 프로세스를 격리해서 가볍고 빠르다

- **2. 왜 VM보다 컨테이너가 좋을까?**

  - VM은 OS전체 부팅이 필요하지미나 컨테이너는 **프로세스 수준**이므로 수 초 이내에 뜸
  - VM 여러 개보다 컨테이너 수십 개가 훨씬 가볍게 올라감
  - CI/CD에서 버전업, 배포 속도가 빨라짐

## 도커를 기반으로 K8s가 왜 필요한가?

- 도커만으로 충분해 보이지만, **실 서비스가 커지면 도커만으로 해결 불가능한 문제들이 생김**

- **도커 단독 운영의 문제**
  - 컨테이너가 죽으면 자동 복구 없음
  - 서버 리소스가 부족해지면 자동으로 새로 증설 불가
  - 롤링 업데이트(무중단 배포) 구현 어려움
  - 서버 여러 대에 컨테이너를 분산해서 배치하기 힘듦
  - 서비스 디스커버리 없음 -> 포트 관리 지옥

이걸 모두 해결하는 시스템이 바로 **쿠버네티스**

## 쿠버네티스의 핵심 개념 단숨에 이해하기

쿠버네티스는 한 문장으로 말하면

> "컨테이너를 자동으로 실행하고 유지하고 치유(heal)하는 오케스트레이션 시스템"

- **Pod**
  - k8s에서 "가장 작은 배포 단위"
  - 하나의 Pod = 하나 이상의 컨테이너
  - 같은 Pod의 컨테이너들은 **같은 네트워크, 볼륨을 공유**
- **Deployment**
  - Pod를 관리하는 상위 개념
  - 3개 replica를 유지한다고 선언하면
    - 죽으면 자동 재시작
    - 부족하면 자동으로 다시 만듦
  - 롤링 업데이트/롤백 지원
- **Service**
  - Pod는 IP가 계속 바뀜 -> 직접 접근 불가
  - **Service는 Pod 앞에 고정 IP를 부여하는 Load Balancer 역할**
  - 종류
    - ClusterIP - 내부 통신용
    - NodePort - 가장 단순한 외부 노출 방식
    - LoadBalancer - 클라우드 환경에서 LB 붙임
- **Ingress**
  - URL path 기반 라우팅
  - 외부 -> 여러 서비스로 라우팅할 때 필수
  - (`/api`, `/admin` 등)
- **ConfigMap / Secret**
  - 환경변수, 설정들을 Pod 외부에 분리
  - Secret은 암호화
- **HPA (Horizontal Pod Autoscaler)**
  - CPU, 메모리, 커스텀 메트릭 기반으로 **자동 스케일 아웃/스케일 인**
- **Node / Cluster / Control Plane**
  - Node = 실제 컨테이너가 올라가는 서버
  - Cluster = Node들의 집합
  - Control Plane = 스케줄링, 모니터링 등 관리 영역
