# Node.js

## V8 엔진

- V8은 Google이 만든 고성능 Javascript 엔진으로, JS 코드를 파싱, 컴파일, 최적화, 실행까지 모두 담당하는 VM (가상 머신)
- Node.js는 이 엔진을 그대로 가져와 서버 사이드 JS 실행 환경으로 만든 것
  - 브라우저에서는 Chrome
  - 서버에서는 Node, Deno, Bun 등 많은 런타임이 V8을 중심으로 움직인다.

### 1. V8의 전체 구조 개요

- V8은 대략 다음 구성 요소로 이루어짐

  1. Parser
  2. Ignition 바이트코드 인터프리터
  3. TurboFan JIT 컴파일러
  4. Garbage Collector (Orinoco) - 힙 메모리 관리
  5. 라이브러리(내장 객체 등)

- 흐름은 다음과 같이 동작

  > JS 코드 -> 파싱 -> AST -> 바이트코드 생성(Ignition) </br>
  > -> 실행 중 프로파일링 -> 최적 경로 수집 </br>
  > -> TurboFan이 최적화된 머신 코드를 생성

- 즉 "처음엔 인터프리터, 나중엔 JIT 컴파일러"
- -> 실행 시간이 길어질수록 성능이 빨라진다.

### 2. 간략 정리

> V8은 Node.js에서 JS를 빠르게 돌려주는 JIT + GC 기반 엔진이고, </br>
> Node는 이 위에 이벤트 루프/비동기 IO를 얹은 런타임이다. </br>
> Java(JVM)랑 비교하면, IO-bound에는 개발, 운영이 가볍고, </br>
> CPU-bound나 강한 타입/툴링 면에서는 Java가 더 유리하다.

### 3. Java(JVM) vs Node.js(V8) - 백엔드 관점에서 장단점 비교

- 공통점

  - JIT + GC가 있는 VM
  - 크로스 플랫폼
  - 장기 실행 서버 프로세스에 적합
  - 성능 튜닝 시, GC, 객체 할당 패턴, 스레드 모델을 의식해야 함

- ☕️ Java(JVM) 쪽이 강한 부분

  - **1. 멀티 스레드 & 병렬 처리**
    - JVM은 스레드/락/동시성 라이브러리/가상 스레드(Loom) 등 CPU-bound, 복잡한 동시성 처리에 훨씬 적합
    - 여러 코어를 적극 활용하기 좋은 구조 (물론 Node도 cluster나 worker로 나눌 수 있찌만 복잡함)
  - **2. 성숙한 GC & 튜닝 옵션**
    - G1, ZGC, Shenandoah 등 다양한 GC 알고리즘
    - GC pause를 줄이고 싶은 경우 선택지가 많음
    - 진짜 하드코어 튜닝도 가능
  - **3. 정적 타입 + 풍부한 엔터프라이즈 생태계**
    - 컴파일 타임 검증, IDE 지원, 리팩터링에 강함
    - 대규모 코드베이스, 금융, 엔터프라이즈 도메인에 강함
    - Spring 등 서버 프레임워크 성숙
  - **4. 툴링/옵저버빌러티**
    - JFR, JMX, VisualVM, Flight Recorder, Mission Control 등
    - JVM 프로파일링, 히스토리, 스레드 덤프, 힙 덤프 툴이 매우 뛰어남

- ✅ Node.js(V8) 쪽이 강한 부분

  - **1. 개발 생산성 & 언어 일원화**
    - 프론트/백 모두 JS/TS로 작성 -> 컨텍스트 전환 비용 낮음
    - 경량 API 서버, BFF, SPA 백엔드 등에 적합
  - **2. IO-bound 서비스에 강함**
    - 싱글 스레드 + 비동기 IO 모델 -> 적은 자원으로 많은 동시 연결 처리 (채팅, 게이트웨이, BFF 등)
  - **3. 경량 배포 & 빠른 부팅**
    - JAR/전통적 애플리케이션보다 부팅 속도 빠른 편
    - 컨테이너 환경에서 작은 서비스 여러 개 띄우기 좋음
  - **4. 생태계와 속도**
    - NPM 생태계 폭발적
  - 빠른 실험/PoC, API 게이트웨이, 엣지 컴퓨팅 등에 적합
