# Kafka 기본

## 카프카의 기본 동작 원리

카프카는 기본적으로 **분산 커밋 로그(Distributed Commit Log)**를 기반으로 동작한다.

- **발행 (Produce)** : 프로듀서가 특정 **Topic**으로 메시지를 보낸다. 
  - 이 때 메시지는 토픽 내의 특정 **Partition**에 순차적으로 쌓인다.
- **저장 (Store)** : 브로커는 메시지에 고유한 번호인 **Offset**을 부여하여 디스크에 저장한다.
- **구독 (Consume)** : 컨슈머는 자신이 어디까지 읽었는지를 기록하는 **Consumer Offset**을 관리한다.
  - "나 5번까지 읽었어"라고 알리면, 다음번엔 6번부터 읽어가는 방식이다.

## 왜 브로커는 보통 '3대'인가?

운영 환경에서 브로커를 최소 3대로 구성하는 이유는 **가용성**과 **데이터 유실 방지** 사이의 최적의 밸런스 떄문이다. 이를 **Quorum(의결 정족수)** 개념과 연결해 볼 수 있다.

- **1. 고가용성**
  - 1대라면 : 브로커 장애 시 전체 시스템이 중단된다. (SPOF - Single Point of Failure)
  - 2대라면 : 한 대가 죽으면 남은 한 대가 모든 짐을 지지만, 만약 남은 한 대마저 장애가 나거나 점검이 필요하면 대안이 없다.
    - 또한 `min.isr=2` 설정을 사용할 수 없어 데이터 안정성이 떨어진다.
  - 3대라면 : 한 대가 장애로 내려가도 나머지 2대가 **복제본**을 유지하며 서비스를 지속할 수 있다.

- **2. 과반수 투표와 리더 산출**
  - 카프가는 내부적으로 메타데이터 관리(Zookeeper 사용 시)나 컨트롤러 선출 시 **과반수(majority)** 원칙을 사용한다.
  - 3대 중 2대가 살아있다면 "과반수가 살아있다"고 판단하여 시스템을 정상으로 간주하고 리더를 새로 선출할 수 있다.
  - 수학적으로 `2n+1`의 형태로 구성할 때 장애 내성 효율이 가장 좋다.

- **3. min.insync.replicas와의 관계**
  - RF(Replication Factor)= 3, min.isr=2 설정이 가장 대중적이다.
  - 브로커 3대가 있어야 한 대가 고장 나더라도 `min.isr=2` (복제보 2개 보장)를 만족하며 계속 메시지를 쓸 수 있다.